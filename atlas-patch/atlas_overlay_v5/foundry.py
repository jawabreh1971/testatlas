from __future__ import annotations

import io, json, zipfile, re
from typing import Any, Dict, List
from urllib.parse import urlparse

import requests
from fastapi import FastAPI, APIRouter, Request, HTTPException
from fastapi.responses import JSONResponse

from .common import connect, now_iso, require_admin, sha256_bytes

CATALOG_TABLE = "foundry_catalog"
TREE_TABLE = "foundry_tree"

def _init_db() -> None:
    con = connect()
    try:
        con.execute(f"""
        CREATE TABLE IF NOT EXISTS {CATALOG_TABLE} (
          id TEXT PRIMARY KEY,
          kind TEXT NOT NULL,
          title TEXT NOT NULL,
          description TEXT NOT NULL,
          tags_json TEXT NOT NULL,
          meta_json TEXT NOT NULL,
          updated_at TEXT NOT NULL
        )
        """)
        con.execute(f"""
        CREATE TABLE IF NOT EXISTS {TREE_TABLE} (
          id TEXT PRIMARY KEY,
          parent_id TEXT,
          name TEXT NOT NULL,
          kind TEXT NOT NULL,
          meta_json TEXT NOT NULL,
          updated_at TEXT NOT NULL
        )
        """)
        con.commit()
    finally:
        con.close()

def _default_seed() -> None:
    con = connect()
    try:
        c = con.execute(f"SELECT COUNT(1) AS n FROM {TREE_TABLE}").fetchone()
        if int(c["n"]) > 0:
            return
        now = now_iso()
        nodes = [
            ("root", None, "Atlas", "platform", {"version":"unified"}, now),
            ("engines", "root", "Engines", "group", {"items":["readiness","compare","artifacts"]}, now),
            ("plugins", "root", "Plugins", "group", {"items":["registry","installer"]}, now),
            ("foundry", "root", "Foundry", "group", {"items":["catalog","builder","web_agent"]}, now),
        ]
        for nid, pid, name, kind, meta, t in nodes:
            con.execute(
                f"INSERT INTO {TREE_TABLE} (id,parent_id,name,kind,meta_json,updated_at) VALUES (?,?,?,?,?,?)",
                (nid, pid, name, kind, json.dumps(meta), t)
            )
        con.commit()
    finally:
        con.close()

def _catalog_seed() -> None:
    con = connect()
    try:
        c = con.execute(f"SELECT COUNT(1) AS n FROM {CATALOG_TABLE}").fetchone()
        if int(c["n"]) > 0:
            return
        now = now_iso()
        items = [
            ("builder_engine", "engine", "Builder Engine", "Generate plugin skeletons & zip artifacts.", ["codegen","plugins"], {"maturity":"mvp"}, now),
            ("web_agent", "engine", "Web Research Agent", "Server-side web fetch + extract titles/snippets.", ["web","research"], {"maturity":"mvp"}, now),
            ("meta_catalog", "foundry", "Meta Catalog", "Catalog of assets, engines, templates, and rules.", ["catalog","meta"], {"maturity":"mvp"}, now),
        ]
        for _id, kind, title, desc, tags, meta, t in items:
            con.execute(
                f"INSERT INTO {CATALOG_TABLE} (id,kind,title,description,tags_json,meta_json,updated_at) VALUES (?,?,?,?,?,?,?)",
                (_id, kind, title, desc, json.dumps(tags), json.dumps(meta), t)
            )
        con.commit()
    finally:
        con.close()

def _safe_url(u: str) -> bool:
    try:
        p = urlparse(u)
        if p.scheme not in {"http","https"}:
            return False
        if not p.netloc:
            return False
        if p.hostname in {"localhost","127.0.0.1"}:
            return False
        return True
    except Exception:
        return False

def _extract_basic(html: str) -> Dict[str, Any]:
    title = ""
    m = re.search(r"<title[^>]*>(.*?)</title>", html, re.I|re.S)
    if m:
        title = re.sub(r"\s+", " ", m.group(1)).strip()[:180]
    text = re.sub(r"(?is)<script.*?</script>", " ", html)
    text = re.sub(r"(?is)<style.*?</style>", " ", text)
    text = re.sub(r"(?is)<[^>]+>", " ", text)
    text = re.sub(r"\s+", " ", text).strip()
    snippets = [text[:240], text[240:480], text[480:720]]
    snippets = [s for s in snippets if s]
    return {"title": title, "snippets": snippets}

def _plugin_zip_from_spec(spec: Dict[str, Any]) -> bytes:
    pid = (spec.get("id") or spec.get("name") or "plugin").strip().lower()
    pid = re.sub(r"[^a-z0-9_\-]+", "_", pid)[:48].strip("_") or "plugin"
    name = spec.get("name") or pid
    version = spec.get("version") or "0.1.0"
    prefix = f"/api/plugins/{pid}"
    manifest = {
        "id": pid,
        "name": name,
        "version": version,
        "description": spec.get("description") or "Generated by Atlas Foundry Builder Engine",
    }
    router_py = (
        "from fastapi import APIRouter\n\n"
        f"router = APIRouter(prefix=\"{prefix}\", tags=[\"plugins\"])\n\n"
        "@router.get(\"/ping\")\n"
        "def ping():\n"
        f"    return {{\"ok\": True, \"plugin\": \"{pid}\", \"generated\": True}}\n"
    )
    buf = io.BytesIO()
    with zipfile.ZipFile(buf, "w", compression=zipfile.ZIP_DEFLATED) as z:
        z.writestr(f"{pid}/manifest.json", json.dumps(manifest, indent=2))
        z.writestr(f"{pid}/backend/router.py", router_py)
    return buf.getvalue()

def install_foundry(app: FastAPI) -> None:
    _init_db()
    _default_seed()
    _catalog_seed()

    r = APIRouter(prefix="/api/foundry", tags=["foundry"])

    @r.get("/catalog")
    def catalog():
        con = connect()
        try:
            rows = con.execute(f"SELECT id, kind, title, description, tags_json, meta_json, updated_at FROM {CATALOG_TABLE} ORDER BY updated_at DESC LIMIT 1000").fetchall()
            items = []
            for x in rows:
                d = dict(x)
                d["tags"] = json.loads(d.get("tags_json") or "[]")
                d["meta"] = json.loads(d.get("meta_json") or "{}")
                d.pop("tags_json", None)
                d.pop("meta_json", None)
                items.append(d)
        finally:
            con.close()
        return {"ok": True, "items": items}

    @r.post("/catalog/upsert")
    async def catalog_upsert(request: Request, payload: Dict[str, Any]):
        try:
            require_admin(dict(request.headers))
        except PermissionError as e:
            raise HTTPException(status_code=401, detail=str(e))
        _id = str(payload.get("id") or "").strip()
        if not _id:
            return JSONResponse({"ok": False, "error": "id_required"}, status_code=422)
        kind = str(payload.get("kind") or "asset")
        title = str(payload.get("title") or _id)
        desc = str(payload.get("description") or "")
        tags = payload.get("tags") or []
        meta = payload.get("meta") or {}
        con = connect()
        try:
            con.execute(
                f"INSERT OR REPLACE INTO {CATALOG_TABLE} (id,kind,title,description,tags_json,meta_json,updated_at) VALUES (?,?,?,?,?,?,?)",
                (_id, kind, title, desc, json.dumps(tags), json.dumps(meta), now_iso())
            )
            con.commit()
        finally:
            con.close()
        return {"ok": True, "id": _id}

    @r.get("/tree")
    def tree():
        con = connect()
        try:
            rows = con.execute(f"SELECT id,parent_id,name,kind,meta_json,updated_at FROM {TREE_TABLE} ORDER BY updated_at DESC LIMIT 2000").fetchall()
            items = []
            for x in rows:
                d = dict(x)
                d["meta"] = json.loads(d.get("meta_json") or "{}")
                d.pop("meta_json", None)
                items.append(d)
        finally:
            con.close()
        return {"ok": True, "items": items}

    @r.post("/builder/plugin-zip")
    async def builder_plugin_zip(request: Request, payload: Dict[str, Any]):
        try:
            require_admin(dict(request.headers))
        except PermissionError as e:
            raise HTTPException(status_code=401, detail=str(e))
        spec = payload.get("spec") or {}
        content = _plugin_zip_from_spec(spec)
        sha = sha256_bytes(content)
        from .engines import _store_artifact  # type: ignore
        artifact = _store_artifact("plugin_zip", "plugin.zip", content, {"sha": sha, "name": spec.get("name")})
        return {"ok": True, "artifact": artifact}

    @r.post("/web/search")
    async def web_search(payload: Dict[str, Any]):
        url = (payload.get("url") or "").strip()
        if url:
            if not _safe_url(url):
                return JSONResponse({"ok": False, "error": "unsafe_url"}, status_code=422)
            try:
                resp = requests.get(url, timeout=10, headers={"User-Agent":"AtlasFoundryWebAgent/1.0"})
                data = _extract_basic(resp.text)
                return {"ok": True, "mode": "url", "url": url, "status_code": resp.status_code, "data": data}
            except Exception as e:
                return JSONResponse({"ok": False, "error": "fetch_failed", "detail": str(e)}, status_code=502)

        seeds = payload.get("seed_urls") or []
        out: List[Dict[str, Any]] = []
        for u in seeds[:5]:
            u = str(u).strip()
            if not u or not _safe_url(u):
                continue
            try:
                resp = requests.get(u, timeout=10, headers={"User-Agent":"AtlasFoundryWebAgent/1.0"})
                out.append({"url": u, "status_code": resp.status_code, "data": _extract_basic(resp.text)})
            except Exception:
                out.append({"url": u, "status_code": 0, "data": {"title":"", "snippets":[]}})
        return {"ok": True, "mode": "seed_urls", "items": out}

    app.include_router(r)
